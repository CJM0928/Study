그래프 (グラフ)

    정점(노드)과 그것들을 연결하는 간선(엣지)으로 구성

    1. 정점의 예시 (頂点の例)
    → 정점이란, 그래프의 각 점(노드)에 해당하는 개체, 실제 예시는 다음과 같다
    
      1. 목적지
      2. 웹 페이지
      3. 파일·폴더
      4. 사람

      예
      "사람" 정점       → “사람 간의 관계”를 간선으로 표현
      "웹 페이지" 정점   → "하이퍼링크"로 연결

    2. 간선의 예시 (辺の例)
    → 간선은 정점 간의 연결, 실제 예시는 다음과 같다. 

      1. 도로
      2. 링크
      3. 팔로우 관계

      예
      두 도시를 연결하는 도로
      인스타그램에서 A가 B를 팔로우하는 관계
      한 페이지에서 다른 페이지로 연결되는 링크

그래프 탐색 (グラフの探索)

    구조를 알고 있는 경우(構造がわかっている場合)
    → 그래프의 구조(연결 관계, 경로 등)를 미리 알고 있다면,
      고속으로 탐색을 수행할 수 있다
      (빠른 경로 계산 가능)

    구조를 모르는 경우(構造がわかっていない場合)
    → 그래프의 전체 구조가 불분명할 경우,
      정점을 하나하나 탐색해 나갈 필요가 있다

이때 사용하는 대표적인 탐색 알고리즘은 다음과 같다

    1. 너비 우선 탐색 (BFS / 幅優先探索)

      1. 가까운 정점부터 탐색
      2. 큐(Queue)를 사용함
      3. 최단 거리 탐색에 유리함

          3
          |
      1 — 2 — 4
          |   |
          6   5

    무방향 그래프로 가정하고, 정점 2에서 탐색을 시작
        시작 정점: 2
        탐색을 시작하며 2를 방문하고, 방문 처리
        이때 정점 2에 인접한 정점들을 살펴보면: 1, 3, 4, 5, 6이 있음
    
    인접 정점 큐에 추가
        BFS는 가까운 정점부터 탐색하므로, 연결된 정점들을 순서대로 큐에 추가
        예를 들어, 정점 2에 연결된 순서대로 탐색한다고 하면:
        큐에 1, 3, 4, 5, 6이 순서대로 들어감
        예시에서는 3 → 4 → 5 → 6으로 표현되었는데, 이는 1은 생략하거나 이미 방문 처리된 상황일 수 있음
    
    탐색 과정
        큐에서 맨 앞의 정점부터 하나씩 꺼내며 방문
        방문한 정점과 연결된 다른 정점이 있다면, 아직 방문하지 않은 경우 다시 큐에 추가
        이 과정을 큐가 빌 때까지 반복
    
    2. 깊이 우선 탐색 (DFS / 深さ優先探索)
    
      1. 한 방향으로 깊게 파고든 후, 막히면 되돌아옴   
      2. 스택(Stack) 또는 재귀(Recursion) 사용 
      3. 경로 찾기나 백트래킹 문제에 유리함

    시작: (1,1)
    목표: (3,3)
    
    미로 예시:
    1 1 1 1 1
    1 S 0 1 1
    1 0 0 0 1
    1 1 1 G 1
    
    S = 시작점
    G = 목표점
    0 = 이동 가능
    1 = 벽 (이동 불가)
    
    탐색 흐름:
    (1,1) → (1,2) → (2,2) → (2,3) → (3,3)

    핵심 구성 요소
    | 항목                   | 설명                                                       |
    |-----------------------|------------------------------------------------------------|                                                    
    | `Queue<int[]>`        | 현재 위치를 저장 (x, y 좌표)                                  |
    | `int[][] maze`        | 0: 이동 가능, 1: 벽                                          |
    | `boolean[][] visited` | 각 칸의 방문 여부                                             |
    | 방향 배열              | `dx[] = {0, 0, -1, 1}` / `dy[] = {-1, 1, 0, 0}` (상하좌우)   |
    
    포인트 요약
    - BFS는 **최단 거리** 보장
    - 2차원 공간에서 **큐 + visited[][]** 를 사용해 구현
    - 인접칸은 **상/하/좌/우 4방향**만 확인
