# 고급 정렬 알고리즘 (Shell / Merge / Quick / Heap Sort)

## 1. 쉘 정렬 (Shell Sort)

### 원리
- 삽입 정렬을 개선한 방법
- 일정한 간격(gap)으로 떨어진 원소들끼리 부분 정렬을 반복  
- gap을 점차 줄여가며 마지막에 gap=1일 때 삽입 정렬 수행

### 절차
1. 배열 길이의 절반을 gap으로 설정
2. gap 간격으로 떨어진 원소들끼리 삽입 정렬
3. gap을 줄여가며 반복
4. 최종적으로 gap=1일 때 전체가 정렬됨

### 시간 복잡도
- 평균: O(n^(3/2)) 정도 (구현에 따라 다름)
- 최악: O(n²)
- 최선: O(n log n) (특정 gap 사용 시)

### 특징
- 삽입 정렬보다 빠름
- 구현이 비교적 간단
- 안정 정렬(Stable Sort)은 아님

---

## 2. 병합 정렬 (Merge Sort)

### 원리
- 분할 정복(Divide and Conquer) 기법
- 배열을 절반씩 분할 → 각각 정렬 → 두 배열을 병합

### 절차
1. 배열을 반으로 나눔
2. 재귀적으로 두 부분을 정렬
3. 두 정렬된 부분 배열을 병합

### 예시
```
[5, 3, 8, 4]
→ [5, 3] [8, 4]
→ [3, 5] [4, 8]
→ [3, 4, 5, 8]
```


### 시간 복잡도
- 최선: O(n log n)
- 평균: O(n log n)
- 최악: O(n log n)

### 특징
- 항상 일정한 성능
- 안정 정렬(Stable Sort)
- 추가 메모리 공간 필요 (O(n))

---

## 3. 퀵 정렬 (Quick Sort)

### 원리
- 분할 정복 기법
- pivot(피벗)을 하나 선택 → 피벗 기준으로 작은 값/큰 값으로 분할 → 각각 정렬

### 절차
1. 배열에서 피벗 선택
2. 피벗보다 작은 값은 왼쪽, 큰 값은 오른쪽에 배치
3. 왼쪽/오른쪽 부분 배열에 대해 재귀적으로 정렬
4. 모든 부분 배열이 길이 1이 되면 종료

### 예시
```
[5, 3, 8, 4]
pivot = 5
→ [3, 4] | [5] | [8]
→ [3, 4, 5, 8]
```


### 시간 복잡도
- 최선: O(n log n)
- 평균: O(n log n)
- 최악: O(n²) (이미 정렬된 경우, pivot 선택이 나쁠 때)

### 특징
- 평균적으로 매우 빠름
- 불안정 정렬(Unstable Sort)
- 추가 메모리 사용 적음 (in-place 가능)

---

## 4. 힙 정렬 (Heap Sort)

### 원리
- 완전 이진 트리를 기반으로 한 정렬
- 최대 힙(Max-Heap)을 구성 → 루트(최댓값)를 추출 → 배열 끝에 배치 → 힙 크기 줄이고 다시 힙 구성

### 절차
1. 배열을 힙 구조로 변환 (Heapify)
2. 루트와 마지막 요소를 교환
3. 힙 크기를 줄이고 Heapify 반복
4. 모든 요소가 정렬될 때까지 반복

### 예시
```
[5, 3, 8, 4]
→ 최대 힙: [8, 5, 3, 4]
→ 8 추출 후 [4, 5, 3] Heapify → [5, 4, 3]
→ 5 추출 후 [3, 4]
→ 최종 [3, 4, 5, 8]
```

### 시간 복잡도
- 최선: O(n log n)
- 평균: O(n log n)
- 최악: O(n log n)

### 특징
- 추가 메모리 거의 필요 없음 (in-place)
- 불안정 정렬(Unstable Sort)
- 퀵 정렬보다 조금 느리지만 최악의 경우에도 안정적

---

## 4가지 정렬 알고리즘 비교

| 알고리즘 | 평균 시간 복잡도 | 최악 | 안정성 | 특징 |
|----------|-----------------|------|--------|------|
| 쉘 정렬 | ~O(n^1.5) | O(n²) | 불안정 | 삽입 정렬 개선 |
| 병합 정렬 | O(n log n) | O(n log n) | 안정 | 추가 메모리 필요 |
| 퀵 정렬 | O(n log n) | O(n²) | 불안정 | 평균적으로 가장 빠름 |
| 힙 정렬 | O(n log n) | O(n log n) | 불안정 | 메모리 효율적 |

---

## 시험 대비 포인트 (기본정보기술자)

- 과목 A  
  - 퀵 정렬 평균 시간 복잡도 → O(n log n)  
  - 병합 정렬은 안정 정렬, 퀵/힙 정렬은 불안정 정렬  
  - 힙 정렬은 항상 O(n log n)  

- 과목 B  
  - 주어진 의사코드를 보고 정렬 알고리즘을 식별  
  - 재귀 호출(병합, 퀵) vs 트리 구조(힙) 차이를 파악  
  - 입력 크기 변화에 따른 실행 횟수 추론 문제 출제  

---

