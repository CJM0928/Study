# 三分探索のアルゴリズム (Ternary Search)
## **개념**
- **볼록 함수(convex function)** 또는 
- **오목 함수(concave function)** 에서
- 최소값이나 최대값을 효율적으로 탐색하기 위한 알고리즘입니다.

---

## 개요
- **목적**: 함수 `f(x)`의 최소값(또는 최대값)을 구한다.
- **전제 조건**: 함수 `f(x)`가 **단봉(unimodal, 즉 한 번만 극값을 가지는 형태)**일 때 적용 가능.

---

## 알고리즘 절차

1. 탐색 구간 `[l, r]`을 초기화한다.
2. 탐색 구간이 충분히 작아질 때까지 다음을 반복한다:
   - 구간 `[l, r]`을 3등분한다.
     ```
     m1 = l + (r - l) / 3
     m2 = r - (r - l) / 3
     ```
   - `f(m1)`과 `f(m2)`를 비교한다.
     - **Case 1**: `f(m1) ≤ f(m2)`  
       → 최소값은 왼쪽 구간에 존재하므로, `r ← m2`
     - **Case 2**: `f(m1) > f(m2)`  
       → 최소값은 오른쪽 구간에 존재하므로, `l ← m1`
3. `[l, r]` 범위가 충분히 줄어들면, 그 안의 값이 최소값에 해당한다.

---

## 시각적 해석

- `f(m2)`가 크면, `m2` 오른쪽 구간은 버린다.  
- `f(m1)`이 크면, `m1` 왼쪽 구간은 버린다.  
- 반복할수록 `[l, r]` 구간이 줄어들어 극값에 수렴한다.

---

## 특징
- 시간 복잡도: **O(log N)** (이진 탐색과 유사하게 수렴 속도를 가짐)
- 적용 사례:
  - 함수 최적화 (예: 거리 합이 최소가 되는 점 찾기)
  - 최대/최소값 탐색 (볼록 함수의 peak 찾기)
  - 게임/물리 시뮬레이션 최적화 문제 등

---

## Java 의사코드 예시

```java
double ternarySearch(double l, double r) {
    for (int i = 0; i < 200; i++) { // 반복 횟수는 정확도에 따라 조절
        double m1 = l + (r - l) / 3;
        double m2 = r - (r - l) / 3;

        if (f(m1) <= f(m2)) {
            r = m2;
        } else {
            l = m1;
        }
    }
    return (l + r) / 2; // 최소값이 존재하는 근사 좌표
}
