# 병렬 이진 탐색 (Parallel Binary Search)

## 개요
여러 개의 쿼리에 대해 각각 이진 탐색을 수행하면 일반적으로 `O(Q log T)`의 시간 복잡도가 든다.  
병렬 이진 탐색은 **각 쿼리의 이진 탐색을 동시에 진행**하여 효율을 높이는 기법이다.

---

## 기본 아이디어
- 각 쿼리의 답은 구간 `[0, T]` 안에 존재한다.
- 쿼리마다 "탐색 구간"을 따로 관리한다.
- 각 단계에서 모든 쿼리의 중간값 `mid`를 모아 처리하고, 조건 판정에 따라 탐색 구간을 절반으로 줄인다.
- 이 과정을 `log T`번 반복하면 모든 쿼리의 답을 얻을 수 있다.

---

## 알고리즘 흐름
1. **초기화**  
   - 모든 쿼리의 탐색 구간을 `[0, T]`로 설정한다.

2. **반복 처리**  
   - 각 쿼리의 `mid = (low + high) / 2`를 계산한다.
   - 그 시각 `mid`에서 시뮬레이션 함수 `f(t)`를 평가한다.
   - 판정 결과에 따라 탐색 구간을 갱신한다:
     - 조건을 만족 → `[low, mid]`
     - 조건 불만족 → `[mid+1, high]`

3. **종료 조건**  
   - 각 쿼리의 탐색 구간이 한 점으로 수렴하면 그것이 답이 된다.

---

## 특징
- **장점**  
  - 쿼리마다 독립적으로 이진 탐색하는 것보다 효율적이다.  
  - 한 번의 `f(t)` 평가로 여러 쿼리의 탐색을 동시에 진행할 수 있다.
- **시간 복잡도**  
  - 일반: `O(Q log T)`  
  - 병렬 이진 탐색: 구현에 따라 `O((Q + T) log T)` 정도로 줄일 수 있다.

---

## 사용 예시
- `f(t)` = "시각 t까지 처리한 작업 수"  
- 쿼리: "작업 수가 X 이상이 되는 최소 시각을 구하고 싶다"  
- → 병렬 이진 탐색을 사용하면 모든 쿼리를 동시에 해결할 수 있다.

---

## 의사 코드 (예시)

```pseudo
function parallel_binary_search(queries, T):
    for each query i:
        low[i] = 0
        high[i] = T

    while exists i with low[i] < high[i]:
        for each query i:
            mid[i] = (low[i] + high[i]) / 2
        evaluate f(mid[i]) for all i   // 모아서 판정
        for each query i:
            if f(mid[i]) 조건 만족:
                high[i] = mid[i]
            else:
                low[i] = mid[i] + 1

    return low
