# 황금분할 탐색 (Golden‑Section Search)

**목적**  
단봉(unimodal) 함수 \(f(x)\)의 **최대/최소값**을 1차원 구간에서 효율적으로 찾는 방법.  
이진 탐색은 경계(참/거짓)를, 삼분 탐색은 2점 평가로 범위를 1/3씩 줄이는 반면,  
**황금분할 탐색은 매 루프 함수 평가를 1번만 추가로 수행**하면서도 **구간을 약 40%씩** 줄임

---

## 아이디어 (황금분할 탐색, Golden-Section Search)

- **황금비**  
  \[
  \varphi = \frac{1+\sqrt{5}}{2} \approx 1.618,\quad
  1-\frac{1}{\varphi} \approx 0.381966
  \]

- **구간 내부 점 정의**  
  구간 \([l, r]\)에서 내부 두 점을 다음과 같이 둔다:
  \[
  m_1 = r - \frac{r-l}{\varphi}, \quad
  m_2 = l + \frac{r-l}{\varphi}
  \]

- **효율성**  
  한쪽 구간을 제거할 때 **남는 점 하나는 그대로 재사용**할 수 있어,  
  다음 루프에서는 **함수 평가가 단 1회만 추가**로 충분하다.

- **최소값 탐색**  
  - \(f(m_1) \le f(m_2)\) → 최소는 왼쪽에 가까움 → 오른쪽 제거 (\(r \leftarrow m_2\))  
  - 그렇지 않으면 왼쪽 제거 (\(l \leftarrow m_1\))

- **최대값 탐색**  
  - 방법 1: \(g(x) = -f(x)\)로 변환 후 최소값 탐색 수행  
  - 방법 2: 비교식의 부등호 방향만 반전

---

## 핵심:

- 한 번의 반복에서 함수 평가 1회만 필요 
- 최소/최대 탐색 모두 가능

---

## 전제 조건

- \(f(x)\)는 **단봉(unimodal)**: 구간 내 극값이 1개.
- 연속일 필요는 없지만, 매끄러울수록 수렴이 안정적.
- 종료 기준: 구간 길이 \((r-l)\)가 \(\varepsilon\) 이하가 되면 중단.

---

## 알고리즘 (의사코드)

입력: l, r, ε, 함수 f
φ = (1 + √5) / 2
resphi = 2 - φ // ≈ 0.381966

m1 = r - resphi * (r - l)
m2 = l + resphi * (r - l)
f1 = f(m1)
f2 = f(m2)

while (r - l > ε):
if f1 <= f2: # 최소값 탐색
r = m2
m2 = m1; f2 = f1
m1 = r - resphi * (r - l)
f1 = f(m1) # 새로 1회만 평가
else:
l = m1
m1 = m2; f1 = f2
m2 = l + resphi * (r - l)
f2 = f(m2) # 새로 1회만 평가

return (l + r) / 2 # 극값 위치 근사치

---

## Java 예시 (최소값)


    import java.util.function.DoubleUnaryOperator;
    
    public class GoldenSearch {
        static double search(double l, double r, double eps, DoubleUnaryOperator f) {
            final double phi = (1 + Math.sqrt(5.0)) / 2.0;
            final double resphi = 2 - phi; // ≈ 0.381966011
    
            double m1 = r - resphi * (r - l);
            double m2 = l + resphi * (r - l);
            double f1 = f.applyAsDouble(m1);
            double f2 = f.applyAsDouble(m2);
    
            while (r - l > eps) {
                if (f1 <= f2) {          // 최소값 탐색
                    r  = m2;
                    m2 = m1; f2 = f1;
                    m1 = r - resphi * (r - l);
                    f1 = f.applyAsDouble(m1); // 새 평가: 1회/루프
                } else {
                    l  = m1;
                    m1 = m2; f1 = f2;
                    m2 = l + resphi * (r - l);
                    f2 = f.applyAsDouble(m2); // 새 평가: 1회/루프
                }
            }
            return (l + r) / 2.0;
        }
    
        // 예시 함수: (x-2)^2 + 3  → 최소값은 x=2
        public static void main(String[] args) {
            DoubleUnaryOperator f = x -> (x - 2) * (x - 2) + 3;
            double x = search(-100, 100, 1e-6, f);
            System.out.printf("x≈%.6f, f(x)≈%.9f%n", x, f.applyAsDouble(x));
        }
    }


**최대값을 찾고 싶다면 f1 <= f2 비교를 반대로 하거나, f 대신 x -> -f(x)를 넘겨서 최소화로 변환하기.**

-------

**비교 요약 (표의 핵심만)**

  방법	목적	구간 축소율	함수 평가
  이진 탐색	경계/판정식 찾기	1/2	1회/루프
  삼분 탐색	최대·최소값	1/3	2회/루프
  황금분할 탐색	최대·최소값	약 40%	1회/루프

-------

**팁**

    ε은 문제 요구 정밀도에 맞춰 설정(예: 1e-6).
    
    실수 오차를 고려해 반복 횟수 상한(예: 200회)을 함께 두면 안전.
    
    단봉이 아닌 함수에는 적용하면 안 됩니다(국소해에 갇힐 수 있음).
