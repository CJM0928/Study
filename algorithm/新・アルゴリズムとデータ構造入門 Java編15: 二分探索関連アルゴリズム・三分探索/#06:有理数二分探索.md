# 스턴–브로코트(Stern–Brocot) 트리 기반 분수 탐색

유리수(분수) 영역에서 **부동소수 오차 없이** 목표 분수를 찾거나, 실수를 유리수로 **근사**하고 싶을 때 쓰는 탐색법입니다.  
스턴–브로코트 트리는 모든 **양의 기약분수**를 **중복 없이 정확히 한 번씩** 포함하는 완전 이진트리입니다.

---

## 핵심 아이디어 (Mediant와 경계 갱신)

- 두 분수 `a/b`, `c/d` 사이의 **중항(중간 분수, mediant)** 은  
  \[
  \frac{a+c}{b+d}
  \]  
  입니다.
- 초기 경계:
  - 왼쪽 `L = 0/1 (0)`
  - 오른쪽 `R = 1/0 (∞)`  ← 분모 0은 경계용 센티넬
- 반복:
  1) `M = mediant(L, R) = (L.n + R.n) / (L.d + R.d)`  
  2) 비교:
     - `M < X` → `L ← M`
     - `M > X` → `R ← M`
     - `M == X` → **정답**
- 이 과정을 반복하면, 목표가 **기약 유리수**일 경우 반드시 `M == X`에 도달합니다.

> 사실: 스턴–브로코트 트리의 인접한 두 분수는 교차곱이 1을 만족합니다.  
> 이 성질 덕분에 중항을 계속 끼워 넣으면 모든 양의 기약분수가 정확히 한 번씩 등장합니다.

---

## 언제 쓰나?

- **정확한 유리수 탐색**: `X = p/q` 같은 정확한 분수를 찾고 싶을 때(기약분수일 것).
- **실수 근사**: \(\sqrt{2}\), \(\pi\) 같은 실수를 `ε` 오차 이내로 **유리수 근사**하고 싶을 때.
- **부동소수 오차 방지**: 정수 연산으로만 비교/판정을 처리.

---

## 장단점

### 장점
- 부동소수 없이 **정확한** 비교/탐색 가능.
- 목표가 기약 유리수라면 반드시 도달(종료 보장).

### 주의사항
- 목표가 정확한 유리수가 아니고 종료 조건을 `==`로만 두면 **무한 루프**가 됩니다 → **반복 횟수 제한** 또는 **오차 허용(ε)** 필요.
- 반복이 길어지면 분자/분모가 급격히 커져 **오버플로우** 위험 → `long`/`BigInteger` 사용 권장.
- 시간 복잡도는 목표 분수의 **연분수 전개 길이**(부분몫 합)에 비례. 깊이가 깊어질수록 느려지고 분자/분모가 커집니다.

---

## 의사 코드

```pseudo
function stern_brocot_search(compare, max_iter):
    L = (0, 1)    // 0/1
    R = (1, 0)    // 1/0 (∞)

    for it in 1..max_iter:
        M = (L.n + R.n, L.d + R.d)  // mediant
        s = compare(M)              // -1: M < X, 0: M == X, 1: M > X

        if s == 0:
            return M                // found exact
        else if s < 0:
            L = M
        else:
            R = M

    return M  // 근사치(최대 반복 시점)
