木構造(트리 구조)


  데이터 구조로서의 트리 구조

  
    "나무"라고도 불림
    실제 식물의 나무처럼 한 번 가지를 치면 다시 합쳐지지 않음
    
트리 구조로 표현 가능한 것:


    1. 회사의 조직도
    2. 주소 (예: 국가 → 도 → 시/군 → 동...)
    3. 대량의 데이터를 분류해서 표현할 수 있음

           사장
          /    \
      부장1    부장2
     /   \         \
    사원1  사원2     사원3
  → 위와 같이 상위에서 하위로 가지가 뻗는 구조가 트리(Tree)

그래프와 트리
  
    그래프 (グラフ)
        정점(노드) 과 간선(엣지) 의 집합
        트리의 경우, 정점을 "절점(節点)", 간선을 "가지(枝)" 라고 부르기도 한다
    
    트리 (木)
        모든 정점이 연결되어 있고, 순환(사이클)이 없는 그래프
        즉, 트리는 사이클이 없는 연결 그래프라는 뜻

트리와 그래프의 예시

     1. 트리 (木)
     
        루트 노드에서 시작해 아래로 뻗어가는 구조
        사이클(순환) 없음
        모든 노드가 연결되어 있음
        트리의 조건을 완전히 만족하는 구조
        정상적인 트리

     2. 순환이 있는 그래프 (閉路のあるグラフ)
     
        일부 노드들 사이에 순환(루프)이 존재함
        → 예: 어떤 정점에서 출발해서 다시 그 정점으로 돌아올 수 있음
        트리가 아님 (트리는 순환이 없어야 함)
        트리 아님 – 사이클 있음

    3. 정점이 연결되어 있지 않은 그래프 (頂点が連結していないグラフ)
    
        일부 노드들이 고립되어 있음 (연결 안 됨)
        → 트리는 모든 노드가 연결되어 있어야 함
        트리 아님 – 연결 안 됨

뿌리를 가진 트리 (根付き木)

    뿌리를 가진 트리란?
    "뿌리(root)"가 있는 트리
    트리 구조에서 딱 하나 존재하는 출발점(최상위 노드)

뿌리(root)의 특징

    트리에서 단 하나만 존재하는 정점
    뿌리를 정하면 상하 계층관계를 쉽게 다룰 수 있음
    (예: 부모-자식 관계, 레벨 순서 등)

부모와 자식 (親と子)

    부모 (親)
    서로 연결된 두 정점 중, 뿌리(root)에 더 가까운 정점
    → 위쪽 노드가 아래 노드의 부모

    자식 (子)
    서로 연결된 두 정점 중, 뿌리로부터 더 먼 정점
    → 아래쪽 노드는 위 노드의 자식

요약

      관계	                    정의
    부모 (Parent)	    루트에 더 가까운 쪽의 노드
    자식 (Child)	    루트에서 더 멀어진 쪽의 노드

형제, 자손, 조상 (兄弟と子孫と祖先)


    형제 (兄弟)
    같은 부모를 가진 노드들
    → 부모 노드가 같으면 서로 형제 관계
    
    자손 (子孫)
    어떤 노드의 자식이나 그 자식의 자식까지 포함한 모든 하위 노드
    → "자식의 자식"까지 전부 포함된 하위 관계
    
    조상 (祖先)
    어떤 노드에서 위쪽으로 올라갔을 때 만나는 부모, 부모의 부모… 등 상위 노드들
    → 루트까지 올라가는 모든 경로상의 노드

요약 정리

      개념	                        정의
      형제	                  같은 부모를 가진 노드
      자손	                  어떤 노드의 자식, 손자 등 모든 하위 노드
      조상	                  어떤 노드의 부모, 조부모 등 모든 상위 노드

여러가지 트리

      1. 부분 트리 (部分木)
      트리의 부분 그래프 중, 트리 조건을 만족하는 것
      사장
        \
        부장2
          \
          사원3
          
      전체 트리의 일부분이지만, 이 자체도 트리 구조를 이루고 있음
      루트는 사장이고, 연결은 유지됨 → 부분 트리
      
      2.  숲 (森)
      트리들의 모음
      사이클(순환)이 없는 그래프

      [트리1]
      사장
        \
        부장1
      
      [트리2]
      부장2
        \
        사원3

      트리1과 트리2는 서로 연결되어 있지 않음
      각각은 독립적인 트리 → 이들을 모은 것이 숲
      
      3. 체 트리 (全域木)
      그래프의 모든 정점을 연결한 트리

          사장
        /    \
      부장1  부장2
     /   \     \
    사원1 사원2 사원3

      사장부터 모든 직원까지 한 트리로 연결됨
      순환(사이클) 없음, 모든 노드 포함 → 전체 트리

      4. 최소 전체 트리 (最小全域木 / MST) 
      전체 트리 중 간선의 가중치(비용)의 합이 가장 작은 트리
      구조는 전체 트리와 같을 수 있지만,
      여러 연결 방식 중 가장 효율적인(비용이 낮은) 경로만 선택함
  
      사장
        \
        부장1
       /     \
      사원1  사원2
      
      부장2
        \
        사원3
  
      위 트리는 전체 노드를 연결하면서도, 일부 간선은 생략 (비용 최소화 가정)

진 트리 (二分木) / 삼분 트리 (三分木)

        트리 이름	                            정의
    1. 이진 트리 (二分木)	    모든 노드가 자식을 최대 2개까지 가질 수 있는 트리
    2. 삼분 트리 (三分木)	    모든 노드가 자식을 최대 3개까지 가질 수 있는 트리

    이진 트리 (二分木)
            ○
           / \
         ○    ○
        /      \
       ○        ○

    각 노드의 자식 수 ≤ 2
    왼쪽/오른쪽 자식의 개념이 명확

    삼분 트리 (三分木)
          ○
        / | \
       ○  ○  ○
          |
          ○

    각 노드의 자식 수 ≤ 3
    왼쪽/가운데/오른쪽 자식으로 나뉘기도 함

힙 트리 (Heap Tree / ヒープ木)

    힙 트리는 완전 이진 트리(complete binary tree)의 일종
    부모 노드의 값이 자식 노드의 값보다 크거나(또는 작거나) 같은 트리를 만족함

    최대 힙 (Max Heap) → 부모 ≥ 자식
    최소 힙 (Min Heap) → 부모 ≤ 자식

    1. 최대 힙 (Max Heap)
          9
         / \
       7     5
      / \   / \
      5   1 2   -
   
    모든 부모 노드의 값이 자식보다 크거나 같음
    루트가 항상 가장 큼 → 최댓값을 빠르게 꺼낼 수 있음

    힙의 주요 활용
    1. 우선순위 큐(Priority Queue) 구현
    2. 힙 정렬 (Heap Sort)
    3. 최단 경로 알고리즘 (예: Dijkstra)

    특징 요약    
      항목	                        설명
      구조	                완전 이진 트리 (왼쪽부터 채워짐)
      규칙	                부모 ≥ 자식 (Max Heap) 또는 부모 ≤ 자식 (Min Heap)
      접근 속도	        루트 접근 O(1), 삽입/삭제 O(log N)
      주요 메서드	        insert, extractMax (또는 extractMin)

    2. 최소 힙 (Min Heap)
          2
         / \
        4   5
       / \
      8   9

    → 부모 ≤ 자식 만족
    → 루트: 가장 작은 값 2

    특징 요약
      항목	                        설명
      구조	              완전 이진 트리 (왼쪽부터 차례대로 채워짐)
      용도	              우선순위 큐 (낮은 숫자가 높은 우선순위), 최단 경로 알고리즘 등
      주요 연산	      삽입, 삭제, 최솟값 꺼내기 모두 O(log N)
      Java 구현	      PriorityQueue<Integer> 클래스 사용 (기본이 Min Heap 구조)
      메모리	              배열 기반 구현이 많으며, index로 부모-자식 계산 가능 (i → 2i+1, 2i+2)


  이진 탐색 트리 (Binary Search Tree, BST / 二分探索木)
  
      이진 탐색 트리(BST)는 이진 트리의 한 종류
      1. 부모 노드 ≥ 왼쪽 자식 노드의 값
      2. 부모 노드 ≤ 오른쪽 자식 노드의 값
      이 두가지 조건을 만족해야한다.
      → 이 규칙을 모든 노드에 대해 재귀적으로 적용

      트리 구조
          6
         / \
        4   9
       /   / \
      2   8   11
      부모 6 기준
      1. 왼쪽 자식 4, 오른쪽 자식 9 
      2. 4의 왼쪽 자식은 2 
      3. 9의 왼쪽 자식은 8, 오른쪽 자식은 11 

      주요 특징
        항목	                              설명
        구조	                  왼쪽 < 부모 < 오른쪽
        탐색 속도	          평균 O(log N), 최악 O(N) (편향될 경우)
        활용	                  빠른 검색, 삽입, 삭제가 가능한 트리
        주의	                  정렬된 데이터만 넣으면 한쪽으로 치우쳐 속도 저하 (→ 균형 트리 필요)

      BST로 가능한 일들
        1. 탐색(Search) → 원하는 값을 빠르게 찾음
        2. 삽입(Insert) → 조건에 따라 자리를 찾아 삽입
        3. 삭제(Delete) → 자식 수에 따라 분기 처리
        4. 중위순회 (Inorder Traversal) → 오름차순 정렬 결과 나옴

      비교: 이진 트리 vs 이진 탐색 트리
        항목	            이진 트리	    이진 탐색 트리
        자식 수	    최대 2개	    최대 2개
        값의 정렬	    규칙 없음	    왼쪽 < 부모 < 오른쪽
        탐색 목적	    적합하지 않음	    빠른 탐색 가능


  결정 트리, 구문 트리, 영역 트리, 트라이 트리, 접미사 트리

      1. 결정 트리 (決定木 / Decision Tree)
      
      정의	      조건 분기에 따라 데이터를 분류하는 트리 구조
      특징	      머신러닝의 분류/예측 모델로 자주 사용
      예시	      "나이가 20 이상인가요?" → "그렇다" → "운전 여부" 판단 등

             날씨?
            /     \
         맑음     흐림
         /           \
      운동함        바람?
                     /   \
                  약함   강함
                 /         \
              운동함     운동 안함

      → 조건을 분기하며 내려가는 트리 형태
      → 머신러닝에서 실제로 사용됨

      2. 구문 트리 (構文木 / Syntax Tree)
      
      정의	      프로그램의 소스 코드를 구조적으로 표현한 트리
      특징	      컴파일러나 인터프리터가 코드를 분석 및 해석할 때 사용
      예시	      수식 (3 + 5) * 2 → 트리 구조로 분석 (연산자 우선순위 표현)

      수식: (3 + 5) * 2
             *
            / \
           +   2
          / \
         3   5

       → 컴파일러나 수식 계산기에서 쓰이는 트리
       → 연산자 우선순위도 표현됨

       3. 영역 트리 (領域木 / Spatial Tree)

       정의	          공간(2D, 3D) 상의 객체를 빠르게 검색하기 위한 트리
       특징	          게임, GIS, 물리 엔진 등에서 공간 분할 및 검색 최적화에 사용
       대표 구조	  사분 트리(Quadtree), 옥트리(Octree), KD 트리 등

       2D 공간을 4등분하며 분할
                 전체 공간
              /   |   |   \
            NW   NE   SW   SE
            
       → 게임, 지도, 3D 공간 등에서 충돌 감지, 객체 위치 탐색에 사용

       4. 트라이 트리 (Trie Tree / トライ木)

       정의	      문자열의 접두사 기반 검색을 위한 트리 구조
       특징	      사전(dictionary), 자동완성, 검색엔진 등에 활용
       예시	      "cat", "car", "can" → 공통 접두사 "ca"를 공유하는 트리

       단어: "to", "tea", "ten"
           (root)
             |
             t
             |
             e
           /   \
          a     n
          |
         (끝)
         
         → 문자 하나하나를 노드로 표현, 접두사 재사용

       5. 접미사 트리 (接尾辞木 / Suffix Tree)
       
       정의	      한 문자열의 모든 접미사를 표현하는 트리 구조
       특징	      문자열 패턴 검색, LCP(Longest Common Prefix), DNA 분석 등에 사용
       예시	      문자열 "banana" → "anana", "nana", "ana"... 모두 포함

       문자열 "banana"의 모든 접미사
       banana
       anana
       nana
       ana
       na
       a
       
       → 트리로 구성하면 복잡하지만, 문자열 검색에 매우 강력
