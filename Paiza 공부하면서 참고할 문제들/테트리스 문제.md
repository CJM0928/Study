## 테트리스 완성 코드

```
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int H = Integer.parseInt(st.nextToken()); // 세로(행)
        int W = Integer.parseInt(st.nextToken()); // 가로(열)
        int N = Integer.parseInt(st.nextToken()); // 조각 수

        char[][] board = new char[H][W];
        for (int y = 0; y < H; y++) Arrays.fill(board[y], '.');

        int[] height = new int[W];

        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            int h = Integer.parseInt(st.nextToken()); // 조각 세로
            int w = Integer.parseInt(st.nextToken()); // 조각 가로
            int x = Integer.parseInt(st.nextToken()); // 좌측 시작 열

            // 1) 착지 base
            int base = 0;
            for (int c = x; c < x + w; c++) base = Math.max(base, height[c]);

            // 2) base 위로 h칸 채우기(아래에서 위로)
            for (int dy = 0; dy < h; dy++) {
                int k = base + dy;   // 바닥에서 k칸
                int y = H - 1 - k;   // 배열 y
                if (y < 0) break;    // 넘치면 중단(필요시 게임오버 처리)
                for (int c = x; c < x + w; c++) {
                    board[y][c] = '#';
                }
            }

            // 3) 높이 갱신
            for (int c = x; c < x + w; c++) {
                height[c] = Math.min(H, base + h);
            }
        }

        // 출력(위줄부터)
        for (int y = 0; y < H; y++) {
            System.out.println(new String(board[y]));
        }
    }
}

```

## 문제 풀이 요약

- 보드 크기: 세로 H, 가로 W
- 직사각형 조각: 총 N개, 각 조각은 (h, w, x)
  - h: 조각의 세로 높이
  - w: 조각의 가로 너비
  - x: 조각의 왼쪽 시작 열 인덱스(0 기준)

- 조각은 위에서 수직으로 떨어져 바닥 또는 이미 쌓인 블록에 닿으면 멈춰 고정됨.
- 최종 보드 상태를 '.'/'#'로 출력.

---

## 핵심 아이디어(알고리즘)
### 1) 자료구조 선택

- char[][] board = new char[H][W] : 보드(행=y, 열=x)를 **'.'**로 초기화
- int[] height = new int[W] : 각 열별로 현재 쌓인 높이(바닥=0)
  - → “떨어뜨릴 때 어디까지 내려가야 하나?”를 O(w)에 계산 가능

### 2) 좌표계(중요!)

- 배열은 위에서 아래로 y=0..H-1
- 바닥(y=H-1) 에서 k칸 올라간 위치의 y는 y = H - 1 - k

### 3) 조각 하나 떨어뜨리기

1. 조각이 덮는 열 구간 [x, x+w-1]의 현재 최고 높이 base를 구함
```
int base = 0;
for (int c = x; c < x + w; c++) {
    base = Math.max(base, height[c]);
}
```

2. base 위로 h칸을 아래→위 방향으로 '#' 채움
```
for (int dy = 0; dy < h; dy++) {
    int k = base + dy;        // 바닥에서 k칸
    int y = H - 1 - k;        // 배열 y좌표
    if (y < 0) break;         // 넘치면 중단(게임오버 처리 가능)
    for (int c = x; c < x + w; c++) board[y][c] = '#';
}
```

3. 덮은 열들의 높이를 base + h로 갱신
```
for (int c = x; c < x + w; c++) height[c] = Math.min(H, base + h);
```

---

### 자바 구현 포인트

- Arrays.fill(board[y], '.') : 1차원 배열(한 행)을 빠르게 채움

- StringTokenizer : 입력 토큰화(nextToken())

- 2차원 배열 접근은 board[y][x] 형식으로 통일 → 헷갈림 방지

- 출력도 행→열 순으로
