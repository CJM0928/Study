## DP(동적 계획법, Dynamic Programming)

- 아이디어: 큰 문제를 작은 하위 문제로 나누고, 그 해결 결과를 재사용(저장) 해서 전체를 푸는 방법.

### 언제 쓰나:
- 부분 최적 구조(Optimal Substructure): 전체 최적해가 부분 문제의 최적해로부터 만들어짐.
- 중복 부분 문제(Overlapping Subproblems): 같은 하위 문제가 여러 번 등장.

### 방식 두 가지:
- 메모이제이션(Top-Down): 재귀 + 캐시
- 타뷸레이션(Bottom-Up): 작은 해부터 표 채우기 (네 코드가 이 방식)
- 장점: 브루트포스 대비 엄청난 속도 향상.
- 단점: 상태 공간이 크면 메모리·시간 부담.

--- 

## 0/1 배낭 문제 (0/1 Knapsack)

### 정의 
- 각 물건을 최대 1번만 고를 수 있을 때(0개 or 1개), 제한 용량(또는 예산) 을 넘지 않으면서 가치(또는 목표) 를 최대화하는 문제.

### 대표 상태식(고전형)
- dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])
(i번째 물건을 안 고름 vs 고름)

### 1차원 압축
- for w = W..weight[i] 내림차순 → 같은 물건을 두 번 쓰지 않음(0/1 보장).
