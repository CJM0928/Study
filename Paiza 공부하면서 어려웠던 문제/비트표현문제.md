# 정보표현(文字コード・数値表現) 정리

## 1. 비트 수와 문자 수
- n비트 → 표현 가능 종류 수 = **2ⁿ**
- 필요한 문자 수 = M
- 조건: `2ⁿ ≥ M` → 최소 n 찾기

### 예제
- 영문 대문자(26) + 숫자(10) = 36  
  → 2⁵=32 < 36, 2⁶=64 ≥ 36 → **6비트**

- 영문 대/소문자(52) + 숫자(10) + 기호(10) = 72  
  → 2⁶=64 < 72, 2⁷=128 ≥ 72 → **7비트**

---

## 2. 문자 코드 체계
| 코드명 | 비트 수 | 특징 | 시험 포인트 |
|--------|---------|------|-------------|
| ASCII | 7비트 | 128종류 (영문/숫자/제어문자) | 기본 문자 |
| EUC | 가변 길이 (2바이트 이상) | 일본어/한글 등 다국어 | UNIX |
| UTF-8 | 가변 길이 (1~4바이트) | 유니코드, 국제 표준, ASCII와 호환 | 웹, 국제표준 |

---

## 3. UTF-8 문제 풀이

### ASCII 문자
- 예: `A` (U+0041) → `0x41` (1바이트 그대로)

### 다국어 문자
- 예: `한` (U+D55C)  
  - 범위: U+0800~FFFF → UTF-8에서 **3바이트**  
  - 변환 결과: **ED 95 9C**

---

## 4. 진법 변환 문제
- 10진수 ↔ 2진수 ↔ 16진수 변환 자주 출제

### 예제
- 10진수 255 = 2진수 11111111 = 16진수 FF  
- 2진수 101101 = 10진수 45  

 팁: **16진수 ↔ 2진수**는 4비트 단위로 바로 변환 가능

---

## 5. 정수 범위 (부호 비트 포함)
- n비트 2의 보수 표현  
  - 범위 = −2^(n−1) ~ 2^(n−1)−1  
- 예: 8비트 → −128 ~ +127

---

## 6. 고정소수점 / 부동소수점
- **고정소수점**: 소수점 위치 고정 (정밀도는 일정, 범위 제한적)  
- **부동소수점**: 지수 + 가수로 표현 (범위 넓음, 정밀도 변화)  

### 예제
IEEE754 단정도(32비트) = 부호 1비트 + 지수 8비트 + 가수 23비트

---

## 7. 오버플로 / 언더플로
- **오버플로**: 최대값 초과 → 잘못된 결과  
- **언더플로**: 최소 표현 단위보다 작아져 0으로 근사  

---

##  FE 시험 대비 포인트 요약
1. **2ⁿ ≥ 문자 수** → 최소 비트 구하기  
2. **ASCII = 7비트**, **UTF-8 = 가변 길이**  
3. **진법 변환(2↔10↔16)** 자주 출제  
4. **정수 범위(2의 보수 표현)** 계산 문제  
5. **고정소수점 vs 부동소수점** 특징 비교  
6. **오버플로/언더플로** 개념 문제  

---

## 8. 연습 문제 + 해설

### 문제 1
알파벳 대문자(26), 소문자(26), 숫자(10) 총 62문자를 코드화하려면 최소 몇 비트가 필요할까?  

- 풀이:  
  - 2⁵ = 32 (부족)  
  - 2⁶ = 64 (충분)  
- **정답: 6비트**

---

### 문제 2
8비트 2의 보수 표현으로 나타낼 수 있는 정수 범위는?  

- 풀이:  
  - 범위 = −2^(8−1) ~ 2^(8−1)−1  
  - = −128 ~ +127  
- **정답: −128 ~ +127**

---

### 문제 3
10진수 173을 2진수와 16진수로 변환하라.  

- 풀이:  
  - 173 ÷ 2 → 10101101 (2진수)  
  - 173 ÷ 16 → 0xAD (16진수)  
- **정답: 10101101 (2진수), AD (16진수)**

---

### 문제 4
문자 `あ` (U+3042)를 UTF-8로 변환하라.  

- 풀이:  
  - U+3042 = 12354 (10진수)  
  - 범위: U+0800~FFFF → UTF-8 3바이트  
  - UTF-8 결과: **E3 81 82**  
- **정답: E3 81 82**
