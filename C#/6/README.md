# 🧠 C# vs Java : 스코프 & 메모리 모델 비교

## 1) 예제로 보는 스코프

### C# 예제
```csharp
// スコープを理解しよう
using System;

public class Lesson06
{
    public static void Main()
    {
        int a = 10;      // Main의 로컬 변수
        int b = 20;      // Main의 로컬 변수
        int num = Sum(a, b);
        Console.WriteLine(num);          // 30
        Console.WriteLine("hello " + a); // hello 10
    }

    public static int Sum(int x, int y)  // 매개변수도 Sum의 로컬 변수
    {
        int a = 3; // Sum의 로컬 변수 (Main의 a와 별개)
        Console.WriteLine("hello " + a); // hello 3
        return x + y;
    }
}

```

---

# 출력

```csharp
hello 3
30
hello 10
```

> **Main의 a(10)와 Sum의 a(3)는 스코프가 다른 별개 변수.**

> **x, y는 a, b 값을 복사(pass-by-value) 받아 사용.**
---

## 2) 메모리 모델 큰 그림

| 구분        | C# (.NET)                                                    | Java                                                          |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------- |
| 스택(Stack) | 메서드 호출 프레임, **로컬 변수**, **매개변수** 저장. 값 형식은 값 자체, 참조 형식은 참조 저장 | 메서드 호출 프레임, **로컬 변수**, **매개변수** 저장. 원시 타입은 값 자체, 참조 타입은 참조 저장 |
| 힙(Heap)   | **참조 형식 객체** 저장. 값 형식(struct)이 객체/배열에 포함되면 인라인 저장            | **모든 객체, 배열, 문자열** 저장. 원시 배열은 값 인라인                           |
| 정적/타입 데이터 | `static` 필드 → 타입 로더가 관리 (실질적으론 관리 힙)                         | `static` 필드 → 메서드 영역 + 힙                                      |
| GC        | .NET GC                                                      | JVM GC                                                        |
| 상수/읽기전용   | `const`, `readonly`                                          | `final`                                                       |

> **용어 차이만 다를 뿐, “로컬(스택) / 객체(힙)” 구조는 유사함**

---

## 3) 타입 체계 차이

| 개념          | C#                                                                   | Java                                                          |
| ----------- | -------------------------------------------------------------------- | ------------------------------------------------------------- |
| 값/기본형       | **값 형식(Value Type)**: `int`, `bool`, `struct`, `enum` → 스택 또는 인라인 저장 | **원시 타입(Primitive)**: `int`, `boolean`, `char` → 스택 또는 배열 인라인 |
| 참조형         | `string`, `class`, `array`, `object`, `interface`, `delegate` → 힙    | `String`, 모든 객체, 배열 → 힙                                       |
| 사용자 정의 값 타입 | `struct` 지원                                                          | 없음 (모두 참조 타입)                                                 |

+ **C# struct: 작고 불변(또는 값语의)이 적합한 데이터 모델에 효율적.
필드/배열 요소로 들어가면 객체 안에 인라인 배치되어 할당/캐시 면에서 유리할 수 있음.**

+ **Java: 사용자 정의 값 타입은 표준 기능 아님(프로젝트 Valhalla가 장기적 개선 방향).
→ 사용자 정의 타입은 항상 참조가 힙을 가리킴.**

---

## 4) 매개변수 전달 규칙

| 항목       | C#                                  | Java                                  |
| -------- | ----------------------------------- | ------------------------------------- |
| 기본 규칙    | **Pass-by-Value**. 참조형도 "참조값을 값 복사" | **Pass-by-Value**. 참조 타입도 "참조값을 값 복사" |
| 참조 자체 변경 | `ref`, `out` 키워드로 참조 자체 교체 가능       | 불가                                    |

### C# 예시
```csharp
void Touch(List<int> xs) { xs.Add(1); }
```

### Java 예시
```csharp
void touch(List<Integer> xs) { xs.add(1); }
```

> **하지만 “매개변수 변수”가 가리키는 참조 자체를 다른 객체로 바꾸는 것은**

> **C#은 ref가 가능, Java는 불가.**
---

## 5) 문자열 비교와 불변성

| 항목  | C#                    | Java                           |
| --- | --------------------- | ------------------------------ |
| 불변성 | `string` 불변           | `String` 불변                    |
| 인터닝 | 지원                    | 지원                             |
| 비교  | `==`가 **값 비교** (오버로드) | `==`는 참조 비교, `.equals()`로 값 비교 |

---

## 6) 배열 메모리 차이

| 항목    | C#                               | Java                        |
| ----- | -------------------------------- | --------------------------- |
| 배열 객체 | 참조 형식(힙에 저장)                     | 참조 타입(힙에 저장)                |
| 요소 저장 | 값 타입 배열은 값이 인라인, 참조 타입 배열은 참조 저장 | 원시 배열은 값이 인라인, 참조 배열은 참조 저장 |

#### 예시:

- C#: int[] → 값들이 연속 메모리

- Java: int[] → 값들이 연속 메모리

- 둘 다 String[] → 참조 연속, 객체는 따로 힙에 저장

---

## 7) 상수/읽기 전용 필드

| 목적        | C#                       | Java             |
| --------- | ------------------------ | ---------------- |
| 컴파일타임 상수  | `const`                  | `static final`   |
| 런타임 읽기 전용 | `readonly` (생성자까지 변경 가능) | `final` (재할당 불가) |

---

## 8) ASCII 메모리 다이어그램
### C# 예시
```csharp

[Stack: Main]
  a(int)=10
  b(int)=20
  team(ref) ─────▶ [Heap] List<string> ─▶ ["勇者","戦士","魔法使い"]

[Stack: Sum]
  x(int)=10
  y(int)=20
  a(int)=3   (Main.a와 독립)

```

---

### Java 예시
```csharp

[Stack: main]
  a(int)=10
  b(int)=20
  team(ref) ─────▶ [Heap] ArrayList<String> ─▶ refs ─▶ "勇者","戦士","魔法使い"

[Stack: sum]
  x(int)=10
  y(int)=20
  a(int)=3
```

---

## 9) 기억 포인트 요약
- 메서드마다 로컬 변수는 완전히 독립 (동명이어라도 별개)

- 로컬/매개변수는 스택, 객체/배열/문자열은 힙

- C#은 struct와 ref/out 매개변수로 값/참조 조정 가능

- 문자열: 둘 다 불변, 인터닝 있음. 비교는 C#: ==, Java: equals()

- 배열: 값/원시 배열은 값 인라인, 참조 배열은 참조 저장
