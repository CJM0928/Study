## 呼び出し元へ伝わる例外 (예외 전파 & rethrow)

### 이 코드가 보여주는 것
- Test() 안에서 예외 발생 → 내부에서 한 번 catch
- 그 자리에서 끝내지 않고 throw; 로 다시 던짐 (rethrow)
- 예외가 호출한 쪽(Main) 의 try/catch 로 전파됨
- 결국 Main 쪽 catch (DivideByZeroException) 이 실행됨

---

### C# 코드 (주석 포함 버전)

```
using System;

class Lesson10
{
    public static void Main()
    {
        Console.WriteLine(1);
        try
        {
            int answer = Test(0);
            Console.WriteLine(7);      // ← 여기까지는 오지 않음
            Console.WriteLine(answer); // ← 실행 안 됨
        }
        catch (DivideByZeroException e)
        {
            Console.WriteLine(8);      // ← 여기로 점프
            Console.WriteLine(e);
        }
    }
    
    static int Test(int number)
    {
        Console.WriteLine(2);
        try
        {
            Console.WriteLine(3);
            int answer = 100 / number; // ← 0으로 나누기, 예외 발생
            return answer;             // ← 실행 안 됨
            Console.WriteLine(4);      // ← 도달 불가
        }
        catch (DivideByZeroException e)
        {
            Console.WriteLine(5);      // ← 내부에서 한 번 잡음
            throw;                     // ← 같은 예외를 다시 던짐 (rethrow)
        }
        
        Console.WriteLine(6);          // ← 정상 흐름이면 여기 도달해야 하지만
                                       //    현재 코드는 return이 없어 컴파일 에러 대상
    }
}
```

---

### 실제 출력 흐름

- Test(0) 기준으로 실행 순서를 번호로 보면:
  - Main에서 Console.WriteLine(1); → 1
  - Test(0) 호출
  - Test 안에서 Console.WriteLine(2); → 2
  - try 안의 Console.WriteLine(3); → 3
  - 100 / 0 에서 DivideByZeroException 발생
  - → return answer; / Console.WriteLine(4); 는 실행 안 됨
  - catch 블록으로 이동 → Console.WriteLine(5); → 5
  - throw; 로 예외를 다시 던짐(rethrow)
  - Test 밖으로 예외가 전파되어 Main의 catch (DivideByZeroException) 로 점프
  - Console.WriteLine(8); → 8
  - Console.WriteLine(e); 로 예외 정보 출력
➡ 최종 출력(대략):
```
1
2
3
5
8
System.DivideByZeroException: Attempted to divide by zero.
   at ...
```
> 7은 절대 안 찍히는 게 핵심 포인트.

---

### throw; 의 의미 (C#)

- throw;
  - → 현재 잡은 예외 그대로 다시 던짐
  - → 스택 트레이스(오류 위치 정보)를 유지

- throw e;
  - → 새로 던진 것처럼 취급되어
  - → 스택 트레이스가 rethrow 위치 기준으로 바뀔 수 있음 (원래 위치 정보 손상)

> 실무에선 “로그 찍고 그대로 위로 올리고 싶을 때” → throw; 패턴을 많이 씀.

---

### Test 메서드의 return 문제 (보너스 포인트)

> 지금 코드 그대로라면 C# 컴파일러 입장에서는:
```
static int Test(int number)
{
    try { ... }
    catch { ... }

    Console.WriteLine(6);
}
```
- number != 0 이라면 예외가 안 나고 try 끝나고
  - Console.WriteLine(6); 까지 간 뒤 return 없이 함수가 끝남
- 그래서 실제로는 "모든 코드 경로에서 값이 반환되지 않습니다(CS0161)" 같은 컴파일 에러가 발생할 수 있음

> 실제로 쓰려면 보통 이렇게 해야 안전하다:
```
static int Test(int number)
{
    Console.WriteLine(2);
    try
    {
        Console.WriteLine(3);
        int answer = 100 / number;
        return answer;
    }
    catch (DivideByZeroException e)
    {
        Console.WriteLine(5);
        throw;
    }
    // 혹은 여기서 기본값을 반환
    // return -1;
}
```

---

### Java에서의 대응 개념
> Java에는 C#의 throw; 같은 문법은 없고 항상 throw e;를 사용하지만,  
> 구조적인 개념은 동일하다.

```
public static void main(String[] args) {
    System.out.println(1);
    try {
        int answer = test(0);
        System.out.println(7);
        System.out.println(answer);
    } catch (ArithmeticException e) {
        System.out.println(8);
        e.printStackTrace();
    }
}

static int test(int number) {
    System.out.println(2);
    try {
        System.out.println(3);
        int answer = 100 / number; // /0 → ArithmeticException
        return answer;
    } catch (ArithmeticException e) {
        System.out.println(5);
        throw e;  // 예외를 다시 던져서 호출한 쪽으로 전파
    }
}
```

- Java도 메서드 안에서 예외 → catch → 다시 throw → 호출한 쪽에서 catch 패턴은 동일
- 단, 스택 트레이스 보존 측면에서 C#의 throw; 가 더 명시적이라는 차이가 있음
