## RPGのプレイヤーを継承で書こう – その2 (C# ↔ Java 비교)

### 요약
- Player 클래스를 부모(base class) 로 두고
- Wizard(魔法使い) 클래스를 상속(subclass) 으로 작성
- 부모 배열(Player[]) 안에 자식 객체(Wizard)를 넣어도 동작
- Attack 메서드를 오버라이드하여 직업별 공격 방식 구현
- 이것이 바로 다형성(Polymorphism) 의 대표 예시

### C# 코드 (해설)
```
using System;

class Lesson08
{
    public static void Main()
    {
        Console.WriteLine("=== パーティーでスライムと戦う ===");

        var hero = new Player("勇者");
        var warrior = new Player("戦士");
        var wizard = new Wizard("魔法使い");

        // Player 배열 안에 Wizard도 포함할 수 있다 → Polymorphism
        Player[] party = { hero, warrior, wizard };
        
        foreach (var player in party)
        {
            player.Attack("スライム");
        }
    }
}

class Player
{
    public string Name { get; private set; }

    public Player(string name)
    {
        Name = name;
    }

    // 오버라이드 허용
    public virtual void Attack(string enemy)
    {
        Console.WriteLine(Name + "は、" + enemy + "を攻撃した！");
    }
}

class Wizard : Player
{
    public Wizard(string name) : base(name)
    {
    }

    // 직업별 공격을 재정의
    public override void Attack(string enemy)
    {
        Console.WriteLine("ズバーン！");
        Console.WriteLine(Name + "は、" + enemy + "に炎を放った！");
    }
}

```

### 실행 결과

```
=== パーティーでスライムと戦う ===
勇者は、スライムを攻撃した！
戦士は、スライムを攻撃した！
ズバーン！
魔法使いは、スライムに炎を放った！
```

---

### 이 예제가 보여주는 핵심 개념

#### 1) 상속(Inheritance)
Wizard가 Player의 속성과 메서드를 물려받음
→ 이름(Name)과 기본 Attack() 사용 가능

#### 2) 오버라이드(Override)
Wizard는 Attack()을 자기 직업에 맞게 재정의
→ virtual / override 구조

#### 3) 다형성(Polymorphism)
Player[] 배열 안에 Player + Wizard 를 모두 넣어도
player.Attack() 호출 시,
각 객체의 실제 타입(Wizard / Player)에 따라 동작이 달라짐.

**→ 이것이 객체지향의 핵심 개념!**

---

### Java 버전 (동일 구조)

```
class Player {
    protected String name;

    public Player(String name) {
        this.name = name;
    }

    public void attack(String enemy) {
        System.out.println(name + "は、" + enemy + "を攻撃した！");
    }
}

class Wizard extends Player {
    public Wizard(String name) {
        super(name);
    }

    @Override
    public void attack(String enemy) {
        System.out.println("ズバーン！");
        System.out.println(name + "は、" + enemy + "に炎を放った！");
    }
}

public class Lesson08 {
    public static void main(String[] args) {
        System.out.println("=== パーティーでスライムと戦う ===");

        Player hero = new Player("勇者");
        Player warrior = new Player("戦士");
        Player wizard = new Wizard("魔法使い");

        Player[] party = { hero, warrior, wizard };

        for (Player p : party) {
            p.attack("スライム");
        }
    }
}
```

### C# ↔ Java 비교표

| 개념        | C#                              | Java                          | 설명                           |
| --------- | ------------------------------- | ----------------------------- | ---------------------------- |
| 상속        | `class Wizard : Player`         | `class Wizard extends Player` | 문법만 서로 다름                    |
| 부모 생성자 호출 | `base(name)`                    | `super(name)`                 | 구조 동일                        |
| 오버라이드     | `public override void Attack()` | `@Override` 사용                | C#은 `virtual` 필요             |
| 다형성       | Player[]에 Wizard 저장 가능          | 동일                            | 객체 모양은 Player, 실제 동작은 Wizard |
| 출력 방식     | `$"{Name}"`도 사용 가능              | 문자열 + 연산                      | 문자열 처리 방식 차이                 |
