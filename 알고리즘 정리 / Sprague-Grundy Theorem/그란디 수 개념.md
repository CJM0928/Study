## Grundy 수(Grundy Number)와 mex의 관계 정리

### 1. Grundy 수의 정의 (핵심 구조)

```
grundy(x) = mex({ grundy(y) | y ∈ moves(x) })
```

- `moves(x)` : 현재 상태 x에서 내가 한 번의 행동으로 갈 수 있는 모든 다음 상태 집합
- `grundy(y)` : 그 다음 상태의 Grundy 값
- `mex(S)` : S 안에 없는 가장 작은 비음수 정수

### 2. mex의 결과가 의미하는 것
  
| mex(S) 값 | 해석                                                  | 내 다음 행동 존재 여부        | 현재 상태 의미                     |
| :------- | :-------------------------------------------------- | :------------------- | :--------------------------- |
| **0**    | 다음 상태 중 `grundy=0`이 없음 → 모든 다음 상태가 상대의 **이기는 상태**   |  없음 (모두 막힘)         | **패배 상태 (Losing Position)**  |
| **1 이상** | 다음 상태 중에 `grundy=0`이 있음 → 내가 상대를 **패배 상태로 보낼 수 있음** |  존재함 (이길 수 있는 수 있음) | **승리 상태 (Winning Position)** |

### 3. 한 문장 요약

- `mex(S)`는 "현재 상태에서 내가 새로 가질 수 있는 최소한의 전략 번호"를 의미
- `mex(S)=0`이면 → 모든 선택이 막혀 있음, 즉 패배
- `mex(S)>0`이면 → 이길 수 있는 다음 행동이 존재, 즉 승리

### 4. 예시 — 돌 1, 3, 4개 빼기 게임

| 남은 돌(x) | 가능한 다음 상태 | 다음 Grundy 집합 S | mex(S) | grundy(x) |  내 다음 행동 존재?  |  결과 |
| :-----: | :-------: | :------------: | :----: | :-------: | :-----------: | :-: |
|    0    |     없음    |        ∅       |    0   |     0     |      ❌ 없음     |  패배 |
|    1    |    {0}    |       {0}      |    1   |     1     | ✅ 있음 (0으로 보냄) |  승리 |
|    2    |    {1}    |       {1}      |    0   |     0     |      ❌ 없음     |  패배 |
|    3    |   {2,0}   |      {0,2}     |    1   |     1     |      ✅ 있음     |  승리 |
|    4    |  {3,1,0}  |     {1,1,0}    |    2   |     2     |      ✅ 있음     |  승리 |


### 5. Grundy 수의 본질

| 관점         | 설명                                                         |
| :--------- | :--------------------------------------------------------- |
| **수학적 의미** | Grundy 수는 각 상태를 님(Nim) 게임의 돌 개수로 환산한 값                     |
| **게임적 의미** | “내가 상대를 패배 상태(grundy=0)로 보낼 수 있는가?”를 수치로 표현                |
| **전략적 해석** | grundy=0 → 모든 수가 막힘 / grundy≠0 → 반격 가능한 수가 존재              |
| **결론**     | Grundy 수는 **‘다음 행동의 유무’와 ‘그 행동이 나를 이기게 만드는가’**를 동시에 표현하는 수 |

## 알고리즘(DP로 구현) -> 기본구조

```
package grundy;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;

public class StoneGame {
    static int mex(HashSet<Integer> s) {
        int g = 0;
        while (s.contains(g)) g++;
        return g;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine().trim());

        int[] dp = new int[Math.max(N + 1, 1)];
        dp[0] = 0; // 패배 상태

        for (int x = 1; x <= N; x++) {
            HashSet<Integer> s = new HashSet<>();

            // 가능한 이동: -1, -3, -4
            if (x - 1 >= 0) s.add(dp[x - 1]);
            if (x - 3 >= 0) s.add(dp[x - 3]);
            if (x - 4 >= 0) s.add(dp[x - 4]);

            dp[x] = mex(s);
        }

        System.out.println(dp[N] != 0 ? 1 : 0);
    }
}
```
