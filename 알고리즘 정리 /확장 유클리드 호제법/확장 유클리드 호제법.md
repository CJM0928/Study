## 확장 유클리드 호제법 & 모듈러 역원 정리

### 1. 개요

모듈러(mod) 연산에서 역원(inverse) 이란
다음 식을 만족하는 정수 x 를 말한다.

$$
a \cdot x + p \cdot y \= gcd(a, p)
$$

이때의 `x` 가 바로 **a의 모듈러 역원**(modular inverse) 이다.

---

### 2. 역원이 존재하는 조건

역원이 존재하려면 **a와 p가 서로소(co-prime)** 이어야 한다.

$$
\ gcd(a,p) \= 1
$$

---

### 3. 수학적 원리

유클리드 호제법을 확장하면
다음과 같은 정수 해 `(x,y)` 를 찾을 수 있다.

$$
\ a \cdot x + p \cdot y \= gcd(a,p)
$$

이때 gcd(a,p) = 1 이라면

$$
\ a \cdot x + p \cdot y = 1
$$

→ 양변을 mod p로 보면

$$
\ a \cdot x \= 1(modp)
$$

즉, **x 가 바로 a의 모듈러 역원**이다.

---

### 4. 확장 유클리드 알고리즘 수식 유도
하위 단계에서 항상 다음 식이 성립한다고 가정한다.

$$
\ b \cdot x1+ (a mod b) \cdot y1 = g
$$

여기서

$$
a \bmod b = a - \lfloor \frac{a}{b} \rfloor \cdot b
$$

를 대입하면,

$$
b \cdot x_1 + (a - \lfloor \frac{a}{b} \rfloor \cdot b) \cdot y_1 = g
$$

정리하면:

$$
a \cdot y_1 + b \cdot (x_1 - \lfloor \frac{a}{b} \rfloor \cdot y_1) = g
$$

따라서 새로운 계수는 다음과 같다.

$$
x = y_1, \quad y = x_1 - \lfloor \frac{a}{b} \rfloor \cdot y_1
$$

이게 코드로 구현되는 핵심 부분이다.

---

### 5. 자바 코드 예시 (완전 주석 버전)
```
import java.io.*;
import java.util.*;

public class ModInverse_Euclid {

    // 확장 유클리드 알고리즘
    static long[] egcd(long a, long b) {
        if (b == 0) return new long[]{a, 1, 0};

        long[] r = egcd(b, a % b);
        long g = r[0], x1 = r[1], y1 = r[2];

        // 식 유도:
        // a % b = a - (a/b)*b
        // → a*y1 + b*(x1 - (a/b)*y1) = g
        long x = y1;
        long y = x1 - (a / b) * y1;

        return new long[]{g, x, y};
    }

    // 모듈러 역원 계산
    static Long modInverse(long a, long p) {
        // ⚠️ 자바의 %는 음수 반환 가능하므로 정규화 필요
        a = ((a % p) + p) % p;
        if (a == 0) return null;

        long[] r = egcd(a, p);
        long g = r[0], x = r[1];

        // gcd(a,p) = 1 or -1 → 역원 존재
        if (g != 1 && g != -1) return null;

        // x가 음수일 수 있으므로 다시 정규화
        long inv = ((x % p) + p) % p;
        return inv;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.print("a와 p를 입력하세요 (예: 3 7): ");
        StringTokenizer st = new StringTokenizer(br.readLine());
        long a = Long.parseLong(st.nextToken());
        long p = Long.parseLong(st.nextToken());

        Long inv = modInverse(a, p);
        if (inv == null) {
            System.out.println("역원이 존재하지 않습니다. (gcd(a,p) ≠ 1)");
        } else {
            System.out.println("a의 역원 = " + inv);
            System.out.println("(검증) (a * inv) % p = " + (a * inv % p));
        }
    }
}
```

---

### 6. `((a % p) + p) % p 의 의미`
자바의 % 연산자는 수학적 mod가 아니라 remainder(나머지) 이다.
| 예시         | 수학적 mod | 자바 `%` 결과 |
| ---------- | ------- | --------- |
| `-3 mod 5` | 2       | -3        |
| `-8 mod 5` | 2       | -3        |

그래서 다음과 같이 보정해야 한다 👇
```
((a % p) + p) % p
```

이 식을 통하면 항상

$$
0 \le ((a \bmod p) + p) \bmod p < p
$$

즉, **항상 양의 나머지(정규화된 mod 값)** 을 얻을 수 있다.

---

### 7. 역원이 존재하지 않는 경우
`a`와 `p`가 공약수를 가지면  
어떤 정수 `x`를 곱해도 1이 될 수 없다.
| a  | p  | gcd(a,p) | 역원 존재 여부 |
| -- | -- | -------- | -------- |
| 3  | 7  | 1        | ✅ 존재     |
| 6  | 9  | 3        | ❌ 없음     |
| 7  | 49 | 7        | ❌ 없음     |
| 10 | 17 | 1        | ✅ 존재     |

---

### 8.알고리즘 복잡도
확장 유클리드 알고리즘의 시간복잡도는

$$
O(\log(\min(a, p)))
$$

즉, 매우 빠른 알고리즘이다.
페르마의 소정리 기반 
$\ 𝑎^𝑝−2 mod 𝑝 $ 
계산과 비교해도 거의 동일한 수준의 효율.

---

### 9.페르마의 소정리와의 관계
> 페르마의 소정리  
> 소수 p에 대해,  
> $\ ap−1≡1(modp) $  
> (단, gcd(a, p) = 1)

양변에 a⁻¹을 곱하면:

$$
\ ap−2≡a−1(modp)
$$

즉, p가 **소수일 경우**,
역원은 **빠른 거듭제곱으로도 계산** 가능하다:

```
long inv = modPow(a, p - 2, p);
```

하지만 **p가 소수가 아닐 때는 이 식이 깨지므로**,  
이때는 **확장 유클리드 호제법**을 사용해야 한다.

---

### 10. 요약
| 항목          | 설명                                   |
| ----------- | ------------------------------------ |
| **역원 정의**   | a·x ≡ 1 (mod p)를 만족하는 x              |
| **존재 조건**   | gcd(a,p)=1                           |
| **계산 방법 ①** | 페르마의 소정리 (p가 소수일 때)                  |
| **계산 방법 ②** | 확장 유클리드 알고리즘 (모든 p 가능)               |
| **정규화 필요성** | ((a % p) + p) % p                    |
| **시간 복잡도**  | O(log p)                             |
| **응용 분야**   | 역원, 조합(nCr mod p), DP, 누적합, 페르마 계산 등 |

---
