# 동적 계획법 (Dynamic Programming, DP) 정리  

## 문제 개요

**문제 요약**  
길이 `N`의 수열 `A = (A₁, A₂, ... , Aₙ)`이 주어진다.  
이 수열에서 임의의 부분집합 `S`를 선택했을 때  
`Σ A_k (k ∈ S)` 가 **3의 배수**가 되는 경우의 수를 구하라.  
결과는 `10⁹`로 나눈 나머지를 출력한다.

---

### 입력 예시

```
4
1 2 3 4
```

### 출력 예시

```
6
```


---

## 핵심 개념

### 동적 계획법이란?
> **큰 문제를 작은 문제로 나누고**,  
> **이전 계산 결과를 저장해 재활용하여** 효율적으로 푸는 알고리즘 설계 기법.

- **중복 계산을 방지**하기 위한 방법
- “저장해놓고 다시 쓰기”가 핵심
- **점화식(State Transition Formula)** 를 세우는 것이 관건

---

## 이 문제에서의 접근 방식

| 개념 | 내용 |
|------|------|
| 목표 | 부분집합의 합이 3의 배수가 되는 경우의 수 |
| 아이디어 | 모든 부분집합을 만들지 않고, 합을 **3으로 나눈 나머지**만 관리 |
| 상태 정의 | `dp[r]`: 현재까지 고려한 부분집합 중, 합 % 3 == r 인 경우의 수 |
| 상태 수 | 3 (나머지가 0, 1, 2 인 경우) |

---

## 점화식 (상태 전이식)

각 숫자 `a`에 대해 다음을 반복한다.

1. `a`를 선택하지 않는 경우  
   → 기존 상태 그대로 유지
      next[r] += dp[r]

2. `a`를 선택하는 경우  
   → 나머지가 `(r + a%3)` 으로 이동
   next[(r + a%3) % 3] += dp[r]

3. 갱신된 결과를 `dp = next` 로 대체한다.

---

## 구현 코드 (Java)

```java
import java.io.*;
import java.util.*;

public class Main {
 static final int MOD = 1_000_000_000;

 public static void main(String[] args) throws IOException {
     BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
     int N = Integer.parseInt(br.readLine());
     int[] A = new int[N];
     StringTokenizer st = new StringTokenizer(br.readLine());
     for (int i = 0; i < N; i++) A[i] = Integer.parseInt(st.nextToken());

     long[] dp = new long[3];
     dp[0] = 1; // 공집합(합=0)은 3의 배수

     for (int a : A) {
         long[] next = new long[3];
         int m = Math.floorMod(a, 3); // a%3

         for (int r = 0; r < 3; r++) {
             next[r] = (next[r] + dp[r]) % MOD; // 선택하지 않음
             int nr = (r + m) % 3;              // 선택함 → 나머지 이동
             next[nr] = (next[nr] + dp[r]) % MOD;
         }
         dp = next;
     }

     System.out.println(dp[0] % MOD); // 합이 3의 배수인 경우
 }
}
```

---

## 진행 과정
| 단계  | 입력값 | m=a%3 | dp 상태 변화  | 설명                |
| --- | --- | ----- | --------- | ----------------- |
| 초기  | -   | -     | [1, 0, 0] | 공집합 (합=0)         |
| a=1 | 1   | 1     | [1, 1, 0] | {1} 추가됨           |
| a=2 | 2   | 2     | [2, 1, 1] | {1,2}로 3의 배수 생성   |
| a=3 | 3   | 0     | [4, 2, 2] | {3}, {1,2,3} 등 추가 |

  결과: dp[0] = 4
  
---

## 최종 출력 예시
| 입력            | 출력  | 의미                                 |
| ------------- | --- | ---------------------------------- |
| `3 / 1 2 3`   | `4` | ∅, {3}, {1,2}, {1,2,3}             |
| `4 / 1 2 3 4` | `6` | ∅, {3}, {6}, {1,2}, {3,6}, {1,2,3} |

---

## 시간 복잡도 & 공간 복잡도
| 항목     | 계산량             | 설명               |
| ------ | --------------- | ---------------- |
| 시간 복잡도 | O(N × 3) ≈ O(N) | 각 원소마다 3개의 상태 갱신 |
| 공간 복잡도 | O(3)            | dp[3]만 사용        |

---

