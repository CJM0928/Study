```
paiza 国には 5 つのビタミン 1,2,3,4,5 が存在します。
いま N 個の食材があります。
i 個目の食材は p_i 円で食べることができ、食べるとビタミン j (1 ≦ j ≦ 5) を v_{i,j} だけ摂取できます。
いまからあなたは献立を考えます。
献立に使う食材の集合を T としたとき、W = (W_1, W_2, W_3, W_4, W_5) を W_j = max(v_{i,j}) (i ∈ T) とします。
献立の魅力度を min(W_j) (1 ≦ j ≦ 5) と定義します。
また、献立の費用を Σ p_i (i ∈ T) 円と定義します。
費用が K 円以下の献立のうち、魅力度の最大値を出力してください。
ただし、費用が K 円以下の献立が存在しないなら -1 を出力してください。
```

---

## 入力される値
```
入力は以下のフォーマットで与えられます。

N K
p_1 p_2 ... p_N
v_{1,1} v_{1,2} v_{1,3} v_{1,4} v_{1,5}
v_{2,1} v_{2,2} v_{2,3} v_{2,4} v_{2,5}
...
v_{N,1} v_{N,2} v_{N,3} v_{N,4} v_{N,5}

・ 1 行目には、食材の個数を表す整数 N、費用の上限を表す整数 K がこの順に空白区切りで与えられます。
・ 2 行目には、i 個目の食材の費用 p_i が空白区切りで与えられます。
・ 続く N 行の i 行目には、i 個目の食材を食べることで得られるビタミン j の量 v_{i,j} が空白区切りで与えられます。
・ 入力は合計で N+2 行からなり、入力値最終行の末尾に改行が１つ入ります。


入力値最終行の末尾に改行が１つ入ります。
文字列は標準入力から渡されます。
```

---

## 期待する出力
```
費用が K 円以下の献立のうち、魅力度の最大値を出力してください。
ただし、費用が K 円以下の献立が存在しないなら -1 を出力してください。
最後は改行し、余計な文字、空行を含んではいけません。
```

---

## 条件
```
すべてのテストケースにおいて、以下の条件をみたします。

・ 1 ≦ N ≦ 10^4
・ 1 ≦ K ≦ 10^9
・ 1 ≦ p_i ≦ 10^9
・ 0 ≦ v_{i,j} ≦ 10^9
```
---

## 入力例1
```
3 4
1 2 3
2 3 4 3 2
1 2 3 4 5
5 4 3 2 1
```

## 出力例1
```
2
```
---

## 入力例2
```
3 6
1 2 3
2 3 4 3 2
1 2 3 4 5
5 4 3 2 1
```

## 出力例2
```
4
```
---

## 入力例3
```
3 100
10000000 100000000 100000000
1 1 1 1 1
2 2 2 2 2
3 3 3 3 3
```

## 出力例3
```
-1
```
---

```
package test.test;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

// 식단에 사용되는 식재료의 집합을 T
// T의 비용을 정의하는데
// K엔 이하의 경우
// 1엔 								 {2,3,4,3,2} 매력도는 2
// 2엔 								 {1,2,3,4,5} 메력도는 1
// 3엔 								 {5,4,3,2,1} 매력도는 1
// 1,2엔 {} 안에는, 각 비타민의 최대값을 즉, {2,3,4,4,5} 매력도는 2
// 1,3엔 {} 안에는, 각 비타민의 최대값을 즉, {5,4,4,3,2} 매력도는 2
// 5종류가 가능
// 여기서 K비용안에서, 뽑을수있는 매력도의 최대는 4엔의 매력도 2

public class Test22 {
    public static void main(String[] args) throws IOException {
        // ---------- 입력 ----------
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());   // 재료 수
        long K = Long.parseLong(st.nextToken());    // 비용 한도

        long[] cost = new long[N];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            cost[i] = Long.parseLong(st.nextToken());
        }

        int NUM_VIT = 5;                   // 비타민 종류 수
        long[][] vitamin = new long[N][NUM_VIT];
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < NUM_VIT; j++) {
                vitamin[i][j] = Long.parseLong(st.nextToken());
            }
        }

        // ---------- 상수들 ----------
        final int V1 = 1 << 0;  // 00001
        final int V2 = 1 << 1;  // 00010
        final int V3 = 1 << 2;  // 00100
        final int V4 = 1 << 3;  // 01000
        final int V5 = 1 << 4;  // 10000
        final int FULL = V1 | V2 | V3 | V4 | V5; // 11111 (모든 비타민 충족)

        final long MAX_VIT_VALUE = 1_000_000_000L;
        final long INF = Long.MAX_VALUE; // "무한대" 대체값. 더할 때는 오버플로우 클램핑 필요.

        // ---------- 이분 탐색 ----------
        long lo = -1;                 // 가능한 매력도의 하한
        long hi = MAX_VIT_VALUE + 1;  // 항상 불가능한 경계

        while (lo + 1 < hi) {
            // (lo + hi) >>> 1  은 (lo + hi) / 2 와 동일한 효과.
            // 단, >>> 는 부호 비트를 무시하는 "unsigned right shift" 이므로
            // (lo + hi) 가 overflow 되더라도 안전하게 중간값(mid)을 계산할 수 있다.
            // 직관성은 떨어지지만, 오버플로우 방지를 위한 Java의 관용구.
            long mid = (lo + hi) >>> 1;

            // ---------- 매력도 mid가 가능한지 DP로 판정 ----------
            long[] dp = new long[1 << NUM_VIT]; // 상태 = 충족 비타민 집합(2^5=32 가지)
            Arrays.fill(dp, INF);
            dp[0] = 0L; // 공집합(아무 비타민도 충족 X)은 비용 0

            for (int i = 0; i < N; i++) {
                // 재료 i가 매력도 mid 기준으로 충족하는 비타민 비트마스크 만들기
                int mask = 0;
                for (int j = 0; j < NUM_VIT; j++) {
                    if (vitamin[i][j] >= mid) {
                        // |= : 비트 OR 대입 연산자 (mask = mask | (1<<j))
                        // j번째 비타민을 충족하면 j번째 비트를 1로 "켜서" 표시.
                        mask |= (1 << j);
                    }
                }
                if (mask == 0) {
                    // 이 재료는 매력도 mid 기준으로 충족하는 비타민이 하나도 없음 → 전이 의미 없음
                    continue;
                }
                
                // 1 << 5 -> 32비트
                long[] next = new long[1 << NUM_VIT];
                Arrays.fill(next, INF);

                for (int m = 0; m <= FULL; m++) {
                    long curCost = dp[m];

                    // curCost == INF → 현재 상태 m은 아직 만들지 못한(도달 불가) 상태 → 스킵
                    // 즉, 이 상태에서 '선택/비선택' 전이를 수행할 필요가 없다.
                    if (curCost == INF) {
                        continue;
                    }

                    // ① 선택하지 않음: 상태 유지
                    if (curCost < next[m]) {
                        next[m] = curCost;
                    }

                    // ② 선택함: 새로운 상태 = m OR mask (집합의 합집합)
                    int nm = m | mask;

                    // 비용 누적 (오버플로우 방지 클램핑)
                    long add = cost[i];
                    long newCost;
                    if (curCost > Long.MAX_VALUE - add) {
                        newCost = Long.MAX_VALUE;
                    } else {
                        newCost = curCost + add;
                    }

                    if (newCost < next[nm]) {
                        next[nm] = newCost;
                    }
                }

                dp = next; // 다음 라운드로 전파
            }

            // FULL(11111b) 상태의 최소 비용이 한도 K 이하이면 mid 달성 가능
            boolean ok;
            if (dp[FULL] <= K) {
                ok = true;
            } else {
                ok = false;
            }

            if (ok) {
                lo = mid;  // mid 가능 → 더 큰 값 시도
            } else {
                hi = mid;  // mid 불가능 → 낮춘다
            }
        }

        // 최종 출력 (삼항 연산자 대신 if/else)
        if (lo < 0) {
            System.out.println(-1);
        } else {
            System.out.println(lo);
        }
    }
}
```

---

### 핵심 DP 전이 부분

```
// dp[mask] = 해당 비타민 충족 상태(mask)를 만들 때의 최소비용
// 초기: 아무 비타민도 충족 안 한 상태는 0원
long[] dp = new long[1 << 5]; // 2^5 = 32 상태
Arrays.fill(dp, INF);
dp[0] = 0L;

for (int i = 0; i < N; i++) {
    int mask = 0;
    for (int j = 0; j < 5; j++) {
        // ▶ 이 부분이 “비타민별 최대값을 비트로 표현”하는 부분
        // 현재 재료의 비타민이 매력도(mid) 이상이면, 그 비타민은 충족됨
        if (vitamin[i][j] >= mid) {
            mask |= (1 << j); // j번째 비타민을 만족시킴
        }
    }

    // 충족되는 비타민이 하나도 없으면 skip
    if (mask == 0) continue;

    long[] next = new long[1 << 5];
    Arrays.fill(next, INF);

    for (int m = 0; m < (1 << 5); m++) {
        long curCost = dp[m];
        if (curCost == INF) continue;

        // ① 선택하지 않는 경우 → 상태 유지
        if (curCost < next[m]) {
            next[m] = curCost;
        }

        // ② 선택하는 경우 → OR 연산으로 새 상태 만들기
        //    (여기서 OR가 “비타민 최대값 취합”을 의미함)
        int nm = m | mask;
        long newCost = curCost + cost[i];
        if (newCost < next[nm]) {
            next[nm] = newCost;
        }
    }

    // 현재 상태 갱신
    dp = next;
}

// ▶ 최종적으로 dp[11111(=31)]에 들어있는 값이
//    “모든 비타민을 충족(min 조건 만족)”할 때의 최소 비용
if (dp[(1 << 5) - 1] <= K) {
    // 매력도(mid)는 가능
} else {
    // 매력도(mid)는 불가능
}
```

---

| 코드                                      | 동작 내용                                        | 의미 요약                                           |
| --------------------------------------- | -------------------------------------------- | ----------------------------------------------- |
| `mask = mask or (1 << j)`               | 현재 재료의 j번째 비타민이 `mid` 이상이면 j번째 비트를 1로 켠다.    | → 이 재료가 **비타민 j를 충족**함을 기록 (**비타민별 max 효과**)    |
| `nm = m or mask`                        | 이미 충족된 비타민 상태 `m`과 현재 재료의 충족 상태 `mask`를 합친다. | → 여러 재료의 비타민 효과를 **합집합으로 병합** (**비타민별 max 누적**) |
| `dp[nm] = min(dp[nm], dp[m] + cost[i])` | 새 상태 `nm`을 만들 때의 최소 비용으로 갱신한다.               | → 동일한 비타민 충족 상태 중 **비용이 가장 작은 경우(min)** 만 유지    |
| `dp[31]`                                | 31(=11111₂)은 비타민 5개를 모두 충족한 상태.              | → 모든 비타민의 **최대값이 mid 이상**일 때의 최소 비용             |
| `dp[31] <= K`                           | 모든 비타민을 충족하는 최소 비용이 K 이하인가?                  | → 매력도 `mid`를 **비용 한도 내에서 달성 가능한지** 여부 판정        |

---

## 전체 동작 흐름 (요약)
- mask 만들기
  → 각 재료가 충족하는 비타민을 bit로 표시 (max 효과)

- nm = m or mask
  → 여러 재료를 선택하면서 비타민 최대값을 누적 (합집합)

- dp[nm] = min(...)
  → 같은 상태에서는 비용 최소화 (min)

- dp[31] <= K
  → 모든 비타민을 만족(min 조건 충족)하면서 비용 조건도 충족하는지 확인
