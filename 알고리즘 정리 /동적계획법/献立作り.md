```
paiza 国には 5 つのビタミン 1,2,3,4,5 が存在します。
いま N 個の食材があります。
i 個目の食材は p_i 円で食べることができ、食べるとビタミン j (1 ≦ j ≦ 5) を v_{i,j} だけ摂取できます。
いまからあなたは献立を考えます。
献立に使う食材の集合を T としたとき、W = (W_1, W_2, W_3, W_4, W_5) を W_j = max(v_{i,j}) (i ∈ T) とします。
献立の魅力度を min(W_j) (1 ≦ j ≦ 5) と定義します。
また、献立の費用を Σ p_i (i ∈ T) 円と定義します。
費用が K 円以下の献立のうち、魅力度の最大値を出力してください。
ただし、費用が K 円以下の献立が存在しないなら -1 を出力してください。
```

---

## 入力される値
```
入力は以下のフォーマットで与えられます。

N K
p_1 p_2 ... p_N
v_{1,1} v_{1,2} v_{1,3} v_{1,4} v_{1,5}
v_{2,1} v_{2,2} v_{2,3} v_{2,4} v_{2,5}
...
v_{N,1} v_{N,2} v_{N,3} v_{N,4} v_{N,5}

・ 1 行目には、食材の個数を表す整数 N、費用の上限を表す整数 K がこの順に空白区切りで与えられます。
・ 2 行目には、i 個目の食材の費用 p_i が空白区切りで与えられます。
・ 続く N 行の i 行目には、i 個目の食材を食べることで得られるビタミン j の量 v_{i,j} が空白区切りで与えられます。
・ 入力は合計で N+2 行からなり、入力値最終行の末尾に改行が１つ入ります。


入力値最終行の末尾に改行が１つ入ります。
文字列は標準入力から渡されます。
```

---

## 期待する出力
```
費用が K 円以下の献立のうち、魅力度の最大値を出力してください。
ただし、費用が K 円以下の献立が存在しないなら -1 を出力してください。
最後は改行し、余計な文字、空行を含んではいけません。
```

---

## 条件
```
すべてのテストケースにおいて、以下の条件をみたします。

・ 1 ≦ N ≦ 10^4
・ 1 ≦ K ≦ 10^9
・ 1 ≦ p_i ≦ 10^9
・ 0 ≦ v_{i,j} ≦ 10^9
```
---

## 入力例1
```
3 4
1 2 3
2 3 4 3 2
1 2 3 4 5
5 4 3 2 1
```

## 出力例1
```
2
```
---

## 入力例2
```
3 6
1 2 3
2 3 4 3 2
1 2 3 4 5
5 4 3 2 1
```

## 出力例2
```
4
```
---

## 入力例3
```
3 100
10000000 100000000 100000000
1 1 1 1 1
2 2 2 2 2
3 3 3 3 3
```

## 出力例3
```
-1
```
---

```
package test.test;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

// 식단에 사용되는 식재료의 집합을 T
// T의 비용을 정의하는데
// K엔 이하의 경우
// 1엔 								 {2,3,4,3,2} 매력도는 2
// 2엔 								 {1,2,3,4,5} 메력도는 1
// 3엔 								 {5,4,3,2,1} 매력도는 1
// 1,2엔 {} 안에는, 각 비타민의 최대값을 즉, {2,3,4,4,5} 매력도는 2
// 1,3엔 {} 안에는, 각 비타민의 최대값을 즉, {5,4,4,3,2} 매력도는 2
// 5종류가 가능
// 여기서 K비용안에서, 뽑을수있는 매력도의 최대는 4엔의 매력도 2

public class Test22 {
    public static void main(String[] args) throws IOException {
        // ---------- 입력 ----------
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());   // 재료 수
        long K = Long.parseLong(st.nextToken());    // 비용 한도

        long[] cost = new long[N];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            cost[i] = Long.parseLong(st.nextToken());
        }

        int NUM_VIT = 5;                   // 비타민 종류 수
        long[][] vitamin = new long[N][NUM_VIT];
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < NUM_VIT; j++) {
                vitamin[i][j] = Long.parseLong(st.nextToken());
            }
        }

        // ---------- 상수들 ----------
        final int V1 = 1 << 0;  // 00001
        final int V2 = 1 << 1;  // 00010
        final int V3 = 1 << 2;  // 00100
        final int V4 = 1 << 3;  // 01000
        final int V5 = 1 << 4;  // 10000
        final int FULL = V1 | V2 | V3 | V4 | V5; // 11111 (모든 비타민 충족)

        final long MAX_VIT_VALUE = 1_000_000_000L;
        final long INF = Long.MAX_VALUE; // "무한대" 대체값. 더할 때는 오버플로우 클램핑 필요.

        // ---------- 이분 탐색 ----------
        long lo = -1;                 // 가능한 매력도의 하한
        long hi = MAX_VIT_VALUE + 1;  // 항상 불가능한 경계

        while (lo + 1 < hi) {
            // (lo + hi) >>> 1  은 (lo + hi) / 2 와 동일한 효과.
            // 단, >>> 는 부호 비트를 무시하는 "unsigned right shift" 이므로
            // (lo + hi) 가 overflow 되더라도 안전하게 중간값(mid)을 계산할 수 있다.
            // 직관성은 떨어지지만, 오버플로우 방지를 위한 Java의 관용구.
            long mid = (lo + hi) >>> 1;

            // ---------- 매력도 mid가 가능한지 DP로 판정 ----------
            long[] dp = new long[1 << NUM_VIT]; // 상태 = 충족 비타민 집합(2^5=32 가지)
            Arrays.fill(dp, INF);
            dp[0] = 0L; // 공집합(아무 비타민도 충족 X)은 비용 0

            for (int i = 0; i < N; i++) {
                // 재료 i가 매력도 mid 기준으로 충족하는 비타민 비트마스크 만들기
                int mask = 0;
                for (int j = 0; j < NUM_VIT; j++) {
                    if (vitamin[i][j] >= mid) {
                        // |= : 비트 OR 대입 연산자 (mask = mask | (1<<j))
                        // j번째 비타민을 충족하면 j번째 비트를 1로 "켜서" 표시.
                        mask |= (1 << j);
                    }
                }
                if (mask == 0) {
                    // 이 재료는 매력도 mid 기준으로 충족하는 비타민이 하나도 없음 → 전이 의미 없음
                    continue;
                }
                
                // 1 << 5 -> 32비트
                long[] next = new long[1 << NUM_VIT];
                Arrays.fill(next, INF);

                for (int m = 0; m <= FULL; m++) {
                    long curCost = dp[m];

                    // curCost == INF → 현재 상태 m은 아직 만들지 못한(도달 불가) 상태 → 스킵
                    // 즉, 이 상태에서 '선택/비선택' 전이를 수행할 필요가 없다.
                    if (curCost == INF) {
                        continue;
                    }

                    // ① 선택하지 않음: 상태 유지
                    if (curCost < next[m]) {
                        next[m] = curCost;
                    }

                    // ② 선택함: 새로운 상태 = m OR mask (집합의 합집합)
                    int nm = m | mask;

                    // 비용 누적 (오버플로우 방지 클램핑)
                    long add = cost[i];
                    long newCost;
                    if (curCost > Long.MAX_VALUE - add) {
                        newCost = Long.MAX_VALUE;
                    } else {
                        newCost = curCost + add;
                    }

                    if (newCost < next[nm]) {
                        next[nm] = newCost;
                    }
                }

                dp = next; // 다음 라운드로 전파
            }

            // FULL(11111b) 상태의 최소 비용이 한도 K 이하이면 mid 달성 가능
            boolean ok;
            if (dp[FULL] <= K) {
                ok = true;
            } else {
                ok = false;
            }

            if (ok) {
                lo = mid;  // mid 가능 → 더 큰 값 시도
            } else {
                hi = mid;  // mid 불가능 → 낮춘다
            }
        }

        // 최종 출력 (삼항 연산자 대신 if/else)
        if (lo < 0) {
            System.out.println(-1);
        } else {
            System.out.println(lo);
        }
    }
}
```
